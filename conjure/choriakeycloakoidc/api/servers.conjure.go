// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"net/http"

	"github.com/palantir/conjure-go-runtime/conjure-go-contract/codecs"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/rest"
	"github.com/palantir/witchcraft-go-server/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/wrouter"
)

type Authorize interface {
	// Takes a Keycloak OIDC JWT, returns a Choria JWT
	Get(ctx context.Context, stateArg string, sessionstateArg string, idtokenArg string) (string, error)
}

// RegisterRoutesAuthorize registers handlers for the Authorize endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesAuthorize(router wrouter.Router, impl Authorize) error {
	handler := authorizeHandler{impl: impl}
	resource := wresource.New("authorize", router)
	if err := resource.Get("Get", "/authorize", rest.NewJSONHandler(handler.HandleGet, rest.StatusCodeMapper, rest.ErrHandler)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "Get"))
	}
	return nil
}

type authorizeHandler struct {
	impl Authorize
}

func (a *authorizeHandler) HandleGet(rw http.ResponseWriter, req *http.Request) error {
	state := req.URL.Query().Get("state")
	sessionstate := req.URL.Query().Get("session_state")
	idtoken := req.URL.Query().Get("id_token")
	respArg, err := a.impl.Get(req.Context(), state, sessionstate, idtoken)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}
